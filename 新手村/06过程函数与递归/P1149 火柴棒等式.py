# -*- coding: utf-8 -*-
'''
@Author: wukong
@Date: 2019-06-30 10:03:12
'''
"""
题目描述
给你n根火柴棍，你可以拼出多少个形如“A+B=CA+B=C”的等式？等式中的AA、BB、CC是用火柴棍拼出的整数（若该数非零，则最高位不能是00）。用火柴棍拼数字0-90−9的拼法如图所示：



注意：

加号与等号各自需要两根火柴棍

如果A≠BA≠B，则A+B=CA+B=C与B+A=CB+A=C视为不同的等式(A,B,C>=0A,B,C>=0)

nn根火柴棍必须全部用上

输入输出格式
输入格式：
一个整数n(n<=24)n(n<=24)。

输出格式：
一个整数，能拼成的不同等式的数目。

输入输出样例
输入样例#1： 
14
输出样例#1： 
2
输入样例#2： 
18
输出样例#2： 
9
说明
【输入输出样例1解释】

22个等式为0+1=10+1=1和1+0=11+0=1。

【输入输出样例2解释】

99个等式为：

0+4=4
0+11=11
1+10=11
2+2=4
2+7=9
4+0=4
7+2=9
10+1=11
11+0=11
"""

# （1）加号与等号各用两根火柴棒（再说一遍，可见重要性）。

# （2）如果A != B，则B+A=C与A+B=C视为不同的算式（不知道为什么，反正我一开始没有这样写，就没有AC）。

# （3）N跟火柴棒必须都用上（不写上这个条件的话你就等着WA (Wonderful Answer) 吧）。

# 不知道哪里出错了。。
# f = [0]*10
# f[0]=6;
# f[1]=2;
# f[2]=5;
# f[3]=5;
# f[4]=4;
# f[5]=5;
# f[6]=6;
# f[7]=3;
# f[8]=7;
# f[9]=6; 

# def match(n):
#     temp =0
#     global f
#     while(1):
#         temp += f[int(n%10)]
#         n//=10
#         if n == 0:
#             break
#     return temp

# # n = int(input())
# for k in range(25):
#     n = k
#     total = 0
#     for i in range(100):
#         for j in range(100):
#             tmp = match(i) +match(j) + 4 +match(i+j)
#             if tmp == n:
#                 total +=1 
#                 # print(i,j,i+j,n)
#     print(k,total)

# 下面进行暴力破解 # 80 的正确率 ，无解。。
result = [0] *13    #在这里发现 11 12 这个位置可能有问题，于是手算了一下
n  = input()
result.extend((1,2,8,9,6,9,29,39,36,61,72,100))
print(result[int(n)])