# -*- coding: utf-8 -*-
'''
@Author: wukong
@Date: 2019-06-30 10:03:12
'''
"""
题目描述
给你n根火柴棍，你可以拼出多少个形如“A+B=CA+B=C”的等式？等式中的AA、BB、CC是用火柴棍拼出的整数（若该数非零，则最高位不能是00）。用火柴棍拼数字0-90−9的拼法如图所示：



注意：

加号与等号各自需要两根火柴棍

如果A≠BA≠B，则A+B=CA+B=C与B+A=CB+A=C视为不同的等式(A,B,C>=0A,B,C>=0)

nn根火柴棍必须全部用上

输入输出格式
输入格式：
一个整数n(n<=24)n(n<=24)。

输出格式：
一个整数，能拼成的不同等式的数目。

输入输出样例
输入样例#1： 
14
输出样例#1： 
2
输入样例#2： 
18
输出样例#2： 
9
说明
【输入输出样例1解释】

22个等式为0+1=10+1=1和1+0=11+0=1。

【输入输出样例2解释】

99个等式为：

0+4=4
0+11=11
1+10=11
2+2=4
2+7=9
4+0=4
7+2=9
10+1=11
11+0=11
"""

# （1）加号与等号各用两根火柴棒（再说一遍，可见重要性）。

# （2）如果A != B，则B+A=C与A+B=C视为不同的算式（不知道为什么，反正我一开始没有这样写，就没有AC）。

# （3）N跟火柴棒必须都用上（不写上这个条件的话你就等着WA (Wonderful Answer) 吧）。

# 不知道哪里出错了。。
# f = [0]*10
# f[0]=6;
# f[1]=2;
# f[2]=5;
# f[3]=5;
# f[4]=4;
# f[5]=5;
# f[6]=6;
# f[7]=3;
# f[8]=7;
# f[9]=6; 

# def match(n):
#     temp =0
#     global f
#     while(1):
#         temp += f[int(n%10)]
#         n//=10
#         if n == 0:
#             break
#     return temp

# # n = int(input())
# for k in range(25):
#     n = k
#     total = 0
#     for i in range(100):
#         for j in range(100):
#             tmp = match(i) +match(j) + 4 +match(i+j)
#             if tmp == n:
#                 total +=1 
#                 # print(i,j,i+j,n)
#     print(k,total)

# 下面进行暴力破解 # 80 的正确率 ，无解。。
# result = [0] *13    #在这里发现 11 12 这个位置可能有问题，于是手算了一下
# n  = input()
# result.extend((1,2,8,9,6,9,29,39,36,61,72,100))
# print(result[int(n)])


# new 解决方案
# 1.观察题目
# 首先，我们观察一下，题目的数据范围是n<=24。很明显，数据的范围是非常小的。
# 所以，我们可以先写出一个暴力程序，然后算出所有的结果，再打表即可。
# 2.暴力程序打印
# 我看到很多人的题解里面都是写着什么数据的上限是多少。
#     但是，如果你只是想要做对题目的话，为了保险起见，你可以把数据的上限弄得
# 大一点。虽然可能暴力程序的时间可能会很长，但是我们可以保证没有错漏结果，毕
# 竟，正如老话说得好：“暴力程序不应该加任何优化，而应该优先保证正确度。”况且
# ，我们的这个暴力程序只是为了算出答案然后打表
def violence():
    f = [6,2,5,5,4,5,6,3,7,6]
    
# 打表程序
f = [0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,8,9,6,9,29,39,38,65,88,128]
a = int(input())
print(f[a])